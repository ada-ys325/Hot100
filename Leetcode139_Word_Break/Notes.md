# 139. 单词断开

给定一个字符串 s 和一个字符串字典 wordDict，返回 true 如果 s
可以将其分割成一个或多个字典单词的空格分隔序列。

请注意，词典中的同一个词可能会在分词中重复使用多次。

------------------------------------------------------------------------

### 示例 1：

**输入：**

    s = "leetcode"
    wordDict = ["leet","code"]

**输出：**

    true

**解释：** 返回 true，因为 "leetcode" 可以分割为 "leet code"。

------------------------------------------------------------------------

### 示例 2：

**输入：**

    s = "applepenapple"
    wordDict = ["apple","pen"]

**输出：**

    true

**解释：** 返回 true，因为 "applepenapple" 可以分割为 "apple pen
apple"。 请注意，您可以重复使用字典中的单词。

------------------------------------------------------------------------

### 示例 3：

**输入：**

    s = "catsandog"
    wordDict = ["cats","dog","sand","and","cat"]

**输出：**

    false

------------------------------------------------------------------------

### 限制：

-   1 \<= s.length \<= 300\
-   1 \<= wordDict.length \<= 1000\
-   1 \<= wordDict\[i\].length \<= 20\
-   s 和 wordDict\[i\] 仅由小写英文字母组成。\
-   wordDict 中的所有字符串都是唯一的。




**初步思路** 
我目前的思路，遍历字典，用每个元素前后拼接，然后对比是否等于所需的单词s， 我开始的思路是，用假设字典是A,B,C然后枚举了，s长度为1，2，3，的ABC的排列组合情况，例如S长度为2，则有6种情况，AB,BA,AC,CA,BC,CB，但这样似乎复杂度太大了

### Gemini 分析目前的思路

1.  **如何确定拼接多少个单词？** 目标字符串 `s` 的长度是不确定的。如果 `s` 很长，你需要拼接 3 个、4 个、甚至更多个单词。比如 `s = "applepenapple"`，你需要拼接 3 个单词。所以，你不仅要考虑 `A` 和 `B` 的排列，还要考虑 `AAA`, `AAB`, `AAC`, `ABA`, `ABB`, ... 这种允许重复使用的，长度为 3、4、5... 的所有组合。

2.  **复杂度问题：** 正如你意识到的，这种方法的复杂度会爆炸式增长。假设字典里有 `n` 个单词，目标字符串 `s` 的长度是 `L`。如果你尝试用 `k` 个单词去拼接，并且允许重复使用，那么组合的数量级会是 `n^k`。你需要对所有可能的 `k` 进行尝试，这个计算量是巨大的，对于题目给出的数据范围 (`s.length <= 300`) 来说，是绝对无法通过的。这在算法上被称为**组合爆炸（Combinatorial Explosion）**。

3.  **如何与 `s` 比较？** 拼接完成后，你需要和字符串 `s` 进行比较。这本身没什么问题，但关键在于你要生成 *所有* 可能的拼接结果，这本身就是不高效的。

总的来说，你的思路是**从字典出发，试图去“构建”出目标字符串 `s`**。这个方向是可行的，但问题在于你采用了“无目标的、纯粹的排列组合”方式去构建，导致了巨大的计算量。

### 换个角度思考：从 `s` 出发

我们可以换一个完全相反的思路：**不再从字典出发去构建 `s`，而是从 `s` 本身出发，看它是否能被字典里的单词“拆分”掉。**

这就把问题从一个“组合问题”转换成了一个“拆分”或“决策”问题。

我们来看字符串 `s = "leetcode"` 和字典 `wordDict = ["leet", "code"]`。

1.  我们站在 `s` 的开头，思考如何拆分第一部分。`s` 的前缀有哪些？

      * `"l"` -\> 不在字典里
      * `"le"` -\> 不在字典里
      * `"lee"` -\> 不在字典里
      * `"leet"` -\> **在字典里！** 这是一个有效的拆分点。

2.  既然 `s` 的前 4 个字符 `"leet"` 可以被匹配，那么问题就**转化**成了一个规模更小的子问题：**剩下的字符串 `"code"` 是否也能被字典拆分？**

3.  我们对 `"code"` 重复同样的过程：

      * `"c"` -\> 不在字典里
      * `"co"` -\> 不在字典里
      * `"cod"` -\> 不在字典里
      * `"code"` -\> **在字典里！**

4.  现在，剩下的字符串是空串 `""`。当我们可以把原字符串 `s` 完全拆分，直到最后什么都不剩的时候，我们就成功了！

这种“**一个大问题可以被分解为若干个性质相同、规模更小的子问题**”的特性，是**动态规划 (Dynamic Programming)** 的一个非常明显的标志。

### 动态规划 (DP) 的思路

我们可以定义一个数组 `dp`，让 `dp[i]` 表示字符串 `s` 的**前 `i` 个字符组成的子串 `s[0...i-1]` 是否可以被成功拆分**。

  * `dp` 数组的大小应该是 `s.length() + 1`。`dp[0]` 到 `dp[s.length()]`。
  * `dp[0] = true`。这是一个“哨兵”或“边界条件”，代表一个空字符串总是可以被拆分的。
  * 我们最终要求解的就是 `dp[s.length()]`，即整个 `s` 是否可以被拆分。

那么，如何计算 `dp[i]` 的值呢？

为了判断 `dp[i]` 是 `true` 还是 `false`，我们需要看 `s[0...i-1]` 这个子串。我们可以尝试在中间找一个分割点 `j` (其中 `0 <= j < i`)。

如果满足下面两个条件，那么 `dp[i]` 就可以是 `true`：

1.  `dp[j]` 是 `true`。（也就是说，`s` 的前 `j` 个字符 `s[0...j-1]` 已经被成功拆分了）。
2.  从 `j` 到 `i-1` 的这部分子串 `s[j...i-1]` **正好是字典里的一个单词**。

只要我们能找到**任何一个**满足条件的 `j`，就可以确定 `dp[i] = true`。如果遍历了所有可能的 `j` 都找不到，那么 `dp[i]` 就是 `false`。

**状态转移方程可以写成：**
`dp[i] = OR { dp[j] AND (s[j...i-1] in wordDict) }`  对于所有 `0 <= j < i`

**我们用 `s = "applepenapple"` 举个例子：**

  * `dp[0] = true` (初始值)
  * `dp[1]` (`a`)：`dp[0]` 为 `true`，但 `s[0...0]` (`a`) 不在字典里 -\> `false`
  * ...
  * `dp[5]` (`apple`)：
      * 检查 `j=0`：`dp[0]` 是 `true`，`s[0...4]` (`apple`) 在字典里。太好了！`dp[5]` 就是 `true`。
  * `dp[6]` (`applep`)：
      * 检查 `j=0`：`dp[0]`为`true`，`s[0...5]`不在字典里。
      * 检查 `j=1`...`j=4`：`dp[1]`到`dp[4]`都是`false`。
      * 检查 `j=5`：`dp[5]`为`true`，但 `s[5...5]` (`p`) 不在字典里。
      * 所有 `j` 都试过了，`dp[6]` 为 `false`。
  * ...
  * `dp[8]` (`applepen`)：
      * 检查 `j=0` 到 `j=4` ...
      * 检查 `j=5`：`dp[5]` (`apple`) 是 `true`，并且 `s[5...7]` (`pen`) 在字典里！所以 `dp[8]` 是 `true`。
  * ...
  * `dp[13]` (`applepenapple`)：
      * 检查 `j=8`：`dp[8]` (`applepen`) 是 `true`，并且 `s[8...12]` (`apple`) 在字典里！所以 `dp[13]` 是 `true`。

最终我们得到 `dp[13] = true`，这就是最终答案。

**总结一下：**

你的思路是从小到大“构建”，而动态规划是从大到小“拆分”。DP 通过记录子问题的解（`dp` 数组）来避免重复计算，从而极大地提高了效率。它的复杂度大概是 $O(L^2 \cdot W)$ 或者通过优化达到 $O(L^2)$ 或 $O(L \cdot \text{max\_word\_len})$，其中 `L` 是 `s` 的长度，`W` 是字典单词平均长度，这比指数级的排列组合要高效得多。

你觉得这个动态规划的思路是不是更清晰一些，并且能够有效解决你担心的复杂度问题？我们可以基于这个思路继续讨论实现细节。

### Finally: 算法步骤总结
1.创建一个布尔数组 dp，长度为 s.length() + 1，并全部初始化为 false。

2.将 dp[0] 设置为 true。

3.为了方便快速查找单词，将 wordDict 转换成一个哈希集合 (HashSet)。

4.外层循环 i 从 1 到 s.length()，计算每个 dp[i] 的值。

5.内层循环 j 从 0 到 i-1，寻找分割点。

    截取子串 s.substring(j, i)，即 s[j...i-1]。

    判断 dp[j] 是否为 true 并且截取的子串是否在哈希集合中。

    如果都满足，则将 dp[i] 置为 true，并用 break 结束内层循环（已经找到解，无需再找其他分割点）。

6.所有循环结束后，返回 dp[s.length()] 的值。


### 实例举例
示例演练
让我们来看一个包含s = "catdog"和的小例子wordDict = ["cat", "dog", "catdo"]。

初始设置：

将 wordDict 转换为集合：words = {"cat", "dog", "catdo"}
字符串长度n = 6
创建DP阵列：f = [True, False, False, False, False, False, False]
f[0] = True（空字符串基本情况）
逐步 DP 计算：

i = 1（选中“c”）：

j = 0：检查是否f[0]为真且“c”在单词中
f[0] = True，但 "c" ∉ 单词
结果：f[1] = False
i = 2（选中“ca”）：

j = 0：检查是否f[0]为真并且“ca”在单词中
f[0] = True，但“ca”∉单词
j = 1：检查是否f[1]为真且“a”在单词中
f[1] = False， 跳过
结果：f[2] = False
i = 3（检查“cat”）：

j = 0：检查是否f[0]为真并且单词中存在“cat”
f[0] = True✓ 和“猫”∈单词✓
结果：（f[3] = True找到有效分割！）
i = 4（检查“catd”）：

j = 0：检查是否f[0]为 True 并且“catd”在单词中
f[0] = True，但“catd”∉单词
j = 1：检查是否f[1]为真并且“atd”在单词中
f[1] = False， 跳过
j = 2：检查是否f[2]为 True 并且“td”在单词中
f[2] = False， 跳过
j = 3：检查是否f[3]为真且“d”在单词中
f[3] = True，但 "d" ∉ 单词
结果：f[4] = False
i = 5（检查“catdo”）：

j = 0：检查是否f[0]为 True 并且“catdo”在单词中
f[0] = True✓ 和“catdo”∈单词✓
结果：（f[5] = True找到有效分割！）
i = 6（选中“catdog”）：

j = 0：检查是否f[0]为真并且单词中有“catdog”
f[0] = True，但“catdog”∉单词
j = 1 到 j = 2：跳过（f[1] 和 f[2] 为 False）
j = 3：检查是否f[3]为真并且单词中存在“dog”
f[3] = True✓ 和“狗”∈单词✓
结果：（f[6] = True找到有效分割！）
最终 DP 阵列： f = [True, False, False, True, False, True, True]

答案： f[6] = True，意思是“catdog”可以分割成“cat”+“dog”。

算法正确识别出字符串可以在位置 3 处断开，其中“cat”（位置 0-3）有效，“dog”（位置 3-6）也有效。